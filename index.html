<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Voxel Architect v5.1 - Sync Update</title>
 <style>
 body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
 #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
 #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
 #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; transform: scaleX(-1); pointer-events: none; }
 #ui {
 position: absolute; top: 20px; left: 20px; z-index: 100;
 color: #00f0ff; font-weight: bold; font-size: 14px;
 text-shadow: 0 0 10px #00f0ff; border-left: 3px solid #00f0ff; padding-left: 15px;
 background: rgba(0,0,0,0.6); padding: 15px;
 }
 .stat-val { color: #fff; }
 </style>
</head>
<body>
 <div id="ui">
 <div>BIO_SYNC: ARCHITECT_OS_v4.1</div>
 <div>STATE: <span id="mode" class="stat-val">INITIALIZING</span></div>
 <div>VOXELS: <span id="count" class="stat-val">0</span></div>
 <div style="font-size: 10px; margin-top: 5px; color: #ff3333;">2 FISTS: HOLD TO RESET | 2 PALMS: HOLD TO ROTATE</div>
 <div style="font-size: 10px; color: #ff00ff;">L-THUMB DOWN: BURST | L-THUMB UP: RESTORE</div>
 <div style="font-size: 10px; color: #00ff00;">L-VICTORY: TOGGLE COLOR | R-VICTORY: DISCO (PALM TO STOP)</div>
 <button id="requestPermission" style="display: none; margin-top: 10px; background: #00ff00; color: #000; border: none; padding: 5px 10px; cursor: pointer;">REQUEST CAMERA PERMISSION</button>
 <button id="retryCamera" style="display: none; margin-top: 10px; background: #00f0ff; color: #000; border: none; padding: 5px 10px; cursor: pointer;">RETRY CAMERA</button>
 </div>
 <video id="input_video" autoplay playsinline></video>
 <canvas id="three_canvas"></canvas>
 <canvas id="biometric_canvas"></canvas>
 <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
 <script src="js/audio.js"></script>
 <script src="js/scene.js"></script>
 <script src="js/gestures.js"></script>
 <script>
 const videoElement = document.getElementById('input_video');
 const bioCanvas = document.getElementById('biometric_canvas');
 const bioCtx = bioCanvas.getContext('2d');
 const modeEl = document.getElementById('mode');
 const countEl = document.getElementById('count');
 const requestBtn = document.getElementById('requestPermission');
 const retryBtn = document.getElementById('retryCamera');
 // Use Three.js objects from scene.js (scene, camera, renderer, voxelGroup, currentSketch, voxelManager)
 // placedVoxels and gridSize are managed by VoxelManager in scene.js
 const placedVoxels = voxelManager.voxelData;

 // Crosshair - create here since it's unique to this file
 const crosshair = new THREE.Mesh(
  new THREE.BoxGeometry(gridSize, gridSize, gridSize),
  new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.5 })
 );
 scene.add(crosshair);

 let smoothedLandmarks = { Left: [], Right: [] };
 let gravityEnabled = false;
 let rainbowActive = false;
 let gravityTimer = 0;
 let restoreTimer = 0;
 let prevRotationPos = null;
 const GRAVITY_HOLD = 800;
 const colorPalette = [
  0x00f0ff, 0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff,
  0xffa500, 0x800080, 0x00ff7f, 0xff1493, 0x7fff00, 0x40e0d0,
  0xffd700, 0xff4500, 0x9370db, 0x00ced1, 0xf08080, 0xadff2f,
  0xff6347, 0x00bfff, 0xda70d6
 ];
 let globalColorIndex = 0;
 let leftPeaceWasActive = false;

 // Gesture state variables (shared with gestures.js)
 let isGrabbing = false;
 let grabTimer = 0;
 let grabOffset = new THREE.Vector3();
 let isBuilding = false;
 let buildTimer = 0;
 let isErasing = false;
 let eraseTimer = 0;
 let resetTimer = 0;
 let rotateTimer = 0;

 function getFloorY() {
  const vFOV = THREE.MathUtils.degToRad(camera.fov);
  const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
  return -(height / 2) + (gridSize / 2);
 }
 function drawHUDCircle(ctx, x, y, progress, color) {
  ctx.beginPath();
  ctx.arc(x, y, 35, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * progress));
  ctx.lineWidth = 5; ctx.strokeStyle = color; ctx.stroke();
  ctx.setLineDash([3, 5]);
  ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI * 2); ctx.lineWidth = 1;
  ctx.stroke();
  ctx.setLineDash([]);
 }
 function drawCyberHand(ctx, landmarks, label) {
  if (!smoothedLandmarks[label] || smoothedLandmarks[label].length === 0) {
  smoothedLandmarks[label] = landmarks.map(p => ({...p}));
  } else {
  landmarks.forEach((p, i) => {
  smoothedLandmarks[label][i].x += (p.x - smoothedLandmarks[label][i].x) * 0.45;
  smoothedLandmarks[label][i].y += (p.y - smoothedLandmarks[label][i].y) * 0.45;
  smoothedLandmarks[label][i].z += (p.z - smoothedLandmarks[label][i].z) * 0.1;
  });
  }
  const pts = smoothedLandmarks[label];
  ctx.shadowBlur = 10; ctx.shadowColor = "#00f0ff";
  ctx.beginPath(); ctx.strokeStyle = "rgba(0, 240, 255, 0.6)"; ctx.lineWidth = 2;
  const CONNECTIONS = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[9,10],[10,11],[11,12],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,5]];
  CONNECTIONS.forEach(([a, b]) => {
  ctx.moveTo(pts[a].x * bioCanvas.width, pts[a].y * bioCanvas.height);
  ctx.lineTo(pts[b].x * bioCanvas.width, pts[b].y * bioCanvas.height);
  });
  ctx.stroke();
  pts.forEach((pt, i) => {
  const x = pt.x * bioCanvas.width, y = pt.y * bioCanvas.height;
  if ([4, 8, 12, 16, 20].includes(i)) {
  ctx.strokeStyle = "#00f0ff"; ctx.strokeRect(x - 6, y - 6, 12, 12);
  } else { ctx.fillStyle = "#fff"; ctx.fillRect(x - 2, y - 2, 4, 4); }
  });
 }
 function getDist(p1, p2) { return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2)+(p1.z&&p2.z?Math.pow(p1.z-p2.z,2):0)); }
 function onResults(results) {
  bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
  crosshair.visible = false;
  if (!results.multiHandLandmarks) {
  grabTimer = 0; buildTimer = 0; eraseTimer = 0;
  resetTimer = 0; rotateTimer = 0; gravityTimer = 0; restoreTimer = 0;
  return;
  }
  let lHand = null, rHand = null;
  results.multiHandedness.forEach((hand, idx) => {
  const landmarks = results.multiHandLandmarks[idx];
  drawCyberHand(bioCtx, landmarks, hand.label);
  if(hand.label === 'Left') lHand = smoothedLandmarks['Left'];
  if(hand.label === 'Right') rHand = smoothedLandmarks['Right'];
  });
  if (lHand && rHand) {
  const lFist = lHand[8].y > lHand[6].y && lHand[12].y > lHand[10].y && lHand[16].y > lHand[14].y;
  const rFist = rHand[8].y > rHand[6].y && rHand[12].y > rHand[10].y && rHand[16].y > rHand[14].y;
  const lPalm = lHand[8].y < lHand[6].y && lHand[12].y < lHand[10].y && lHand[20].y < lHand[18].y;
  const rPalm = rHand[8].y < rHand[6].y && rHand[12].y < rHand[10].y && rHand[20].y < rHand[18].y;
  if (lFist && rFist) {
  if (resetTimer < RESET_HOLD) {
  resetTimer += 16;
  drawHUDCircle(bioCtx, bioCanvas.width / 2, bioCanvas.height / 2, resetTimer/RESET_HOLD, "#ff0055");
  modeEl.innerText = "SYSTEM: HOLD TO RESET...";
   } else if (resetTimer >= RESET_HOLD && resetTimer < 2000) {
  voxelGroup.position.set(0, 0, 0);
  voxelGroup.rotation.set(0, 0, 0);
  audioManager.playSound('reset');
  modeEl.innerText = "SYSTEM: HARD_RESET COMPLETE";
  resetTimer = 2000;
  }
  return;
  } else { resetTimer = 0; }
  if (lPalm && rPalm) {
  if (rotateTimer < ROTATE_HOLD) {
  rotateTimer += 16;
  drawHUDCircle(bioCtx, bioCanvas.width / 2, bioCanvas.height / 2, rotateTimer/ROTATE_HOLD, "#00f0ff");
  modeEl.innerText = "SYSTEM: HOLD TO ENABLE ROTATION...";
  } else {
  if (rotateTimer === ROTATE_HOLD) audioManager.playSound('rotate');
  modeEl.innerText = "SYSTEM: GLOBAL_ROTATE ACTIVE";
  const currentPos = { x: rHand[9].x - lHand[9].x, y: rHand[9].y - lHand[9].y };
  if (prevRotationPos) {
  voxelGroup.rotation.y += (currentPos.x - prevRotationPos.x) * 2.0;
  voxelGroup.rotation.x += (currentPos.y - prevRotationPos.y) * 2.0;
  }
  prevRotationPos = currentPos;
  }
  return;
  } else {
  rotateTimer = 0;
  prevRotationPos = null;
  }
  }
  if (lHand) {
  const fingersCurled = lHand[8].y > lHand[6].y && lHand[12].y > lHand[10].y && lHand[16].y > lHand[14].y && lHand[20].y > lHand[18].y;
  const isFist = fingersCurled && getDist(lHand[4], lHand[12]) < 0.1;
  const isPalm = lHand[8].y < lHand[6].y && lHand[12].y < lHand[10].y && lHand[20].y < lHand[18].y;
  const isThumbDown = lHand[4].y > lHand[3].y && lHand[4].y > lHand[17].y && fingersCurled;
  const isThumbUp = lHand[4].y < lHand[3].y && lHand[4].y < lHand[5].y && fingersCurled;
  const isLeftPeace = lHand[8].y < lHand[6].y && lHand[12].y < lHand[10].y && lHand[16].y > lHand[14].y && lHand[20].y > lHand[18].y;
  if (isLeftPeace && !leftPeaceWasActive) {
  globalColorIndex = (globalColorIndex + 1) % colorPalette.length;
  audioManager.playSound('colorChange');
  leftPeaceWasActive = true;
  } else if (!isLeftPeace) {
  leftPeaceWasActive = false;
  }
  if (isPalm) {
  isGrabbing = false;
  grabTimer = 0;
  modeEl.innerText = "BIO_LINK: SCANNING";
  }
  if (isThumbDown && !isFist) {
  restoreTimer = 0;
  if (!gravityEnabled) {
  if (gravityTimer < GRAVITY_HOLD) {
  gravityTimer += 16;
  drawHUDCircle(bioCtx, lHand[4].x * bioCanvas.width, lHand[4].y * bioCanvas.height, gravityTimer/GRAVITY_HOLD, "#ff00ff");
  modeEl.innerText = "BIO_LINK: INITIATING BURST...";
  } else {
  gravityEnabled = true;
  initiateGravityFall();
  audioManager.playSound('gravity');
  modeEl.innerText = "BIO_LINK: GRAVITY_ACTIVE";
  gravityTimer = 0;
  }
  }
  } else if (isThumbUp && !isFist) {
  gravityTimer = 0;
  if (gravityEnabled) {
  if (restoreTimer < GRAVITY_HOLD) {
  restoreTimer += 16;
  drawHUDCircle(bioCtx, lHand[4].x * bioCanvas.width, lHand[4].y * bioCanvas.height, restoreTimer/GRAVITY_HOLD, "#00ff88");
  modeEl.innerText = "BIO_LINK: RESTORING COORDS...";
  } else {
  gravityEnabled = false;
  modeEl.innerText = "BIO_LINK: STRUCTURE_RESTORED";
  restoreTimer = 0;
  }
  }
  } else {
  gravityTimer = 0; restoreTimer = 0;
  }
  if (isFist && !isThumbDown && !isThumbUp) {
  if (grabTimer < GRAB_HOLD) {
  grabTimer += 16;
  drawHUDCircle(bioCtx, lHand[0].x * bioCanvas.width, lHand[0].y * bioCanvas.height, grabTimer/GRAB_HOLD, "#ffbb00");
  } else {
  if (!isGrabbing) audioManager.playSound('grab');
  const handWorldPos = new THREE.Vector3((0.5 - lHand[9].x) * 25, (0.5 - lHand[9].y) * 18, 0);
  if (!isGrabbing){ grabOffset.copy(voxelGroup.position).sub(handWorldPos); isGrabbing = true; }
  voxelGroup.position.copy(handWorldPos).add(grabOffset);
  modeEl.innerText = "BIO_LINK: GRABBED";
  }
  } else if (isGrabbing) {
  const handWorldPos = new THREE.Vector3((0.5 - lHand[9].x) * 25, (0.5 - lHand[9].y) * 18, 0);
  voxelGroup.position.copy(handWorldPos).add(grabOffset);
  }
  }
  if (rHand) {
  const thumbTip = rHand[4], indexTip = rHand[8], midTip = rHand[12];
  const pinchingNow = getDist(thumbTip, indexTip) < pinchThreshold;
  const pointingNow = indexTip.y < rHand[6].y && midTip.y > rHand[10].y;
  const palmOpen = rHand[8].y < rHand[6].y && rHand[12].y < rHand[10].y && rHand[20].y < rHand[18].y;
  const isPeace = indexTip.y < rHand[6].y && midTip.y < rHand[10].y && rHand[16].y > rHand[14].y && rHand[20].y > rHand[18].y;
  if (isPeace && !rainbowActive) {
  rainbowActive = true;
  audioManager.playSound('disco');
  } else if (palmOpen) {
  rainbowActive = false;
  }
  const px = indexTip.x * bioCanvas.width, py = indexTip.y * bioCanvas.height;
  const worldPos = new THREE.Vector3((0.5 - indexTip.x) * 25, (0.5 - indexTip.y) * 18, 0);
  const localPos = voxelGroup.worldToLocal(worldPos.clone());
  let gx = Math.round(localPos.x / gridSize) * gridSize;
  let gy = Math.round(localPos.y / gridSize) * gridSize;
  let gz = 0;
  const lPinching = lHand && getDist(lHand[4], lHand[8]) < pinchThreshold;
  if (lPinching && pointingNow && !palmOpen) {
  buildTimer = 0;
  if (eraseTimer < INTENT_HOLD) {
  eraseTimer += 16;
  drawHUDCircle(bioCtx, px, py, eraseTimer/INTENT_HOLD, "#ff3333");
  modeEl.innerText = "INTENT: ERASER_LOCKING...";
  } else {
  isErasing = true;
  const key = `${gx.toFixed(1)},${gy.toFixed(1)},${gz.toFixed(1)}`;
  voxelManager.removeVoxel(key);
  countEl.innerText = voxelManager.getVoxelCount();
  modeEl.innerText = "INTENT: ERASER_ACTIVE";
  }
  } else if (pinchingNow && !isGrabbing && !palmOpen) {
  eraseTimer = 0;
  if (buildTimer < INTENT_HOLD) {
  buildTimer += 16;
  drawHUDCircle(bioCtx, px, py, buildTimer/INTENT_HOLD, "#00ffcc");
  modeEl.innerText = "INTENT: BUILD_SYNCING...";
  } else {
  if (!isBuilding) { startPinchPos = { x: gx, y: gy, z: gz }; sketchKeys.clear(); isBuilding = true; activeAxis = null; }
  else {
  const dx = Math.abs(gx - startPinchPos.x), dy = Math.abs(gy - startPinchPos.y);
  if (!activeAxis && (dx > 0.4 || dy > 0.4)) {
  if (dx >= dy) activeAxis = 'x';
  else activeAxis = 'y';
  }
  let tx = startPinchPos.x, ty = startPinchPos.y;
  if (activeAxis === 'x') tx = gx; else if (activeAxis === 'y') ty = gy;
  addSketchVoxel(tx, ty, gz);
  }
  modeEl.innerText = "INTENT: BUILDING";
  }
  } else {
  if (palmOpen) { if (isBuilding) commitVoxels(); isBuilding = false; isErasing = false; buildTimer = 0; eraseTimer = 0; modeEl.innerText = "BIO_LINK: NAVIGATING"; }
  }
  if (isBuilding || buildTimer > 0 || isErasing || eraseTimer > 0) {
  crosshair.visible = true;
  crosshair.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx, gy, gz)));
  crosshair.material.color.set((isErasing || eraseTimer > 0) ? 0xff3333 : colorPalette[globalColorIndex]);
  }
  }
  }
  function initiateGravityFall() {
  voxelManager.updatePhysics(true, getFloorY());
  }
  function addSketchVoxel(x, y, z) {
  const key = `${x.toFixed(1)},${y.toFixed(1)},${z.toFixed(1)}`;
  if (sketchKeys.has(key) || voxelManager.voxelData.has(key)) return;
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(gridSize*0.98, gridSize*0.98, gridSize*0.98), new THREE.MeshBasicMaterial({ color: colorPalette[globalColorIndex], wireframe: true }));
  mesh.position.set(x, y, z);
  currentSketch.add(mesh);
  sketchKeys.add(key);
  }
  function commitVoxels() {
  while(currentSketch.children.length > 0) {
  const f = currentSketch.children[0];
  voxelManager.addVoxel(f.position.x, f.position.y, f.position.z, globalColorIndex);
  currentSketch.remove(f);
  }
  countEl.innerText = voxelManager.getVoxelCount();
  }
  // Initialize audio system
  audioManager.init();

  const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
  hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
  hands.onResults(onResults);

  async function initCamera() {
   const constraints = [
     { width: { ideal: 1280 }, height: { ideal: 720 } },
     { width: { ideal: 640 }, height: { ideal: 480 } },
     { width: { ideal: 320 }, height: { ideal: 240 } }
   ];

   for (let constraint of constraints) {
     try {
       console.log(`Attempting to access camera with resolution: ${constraint.width.ideal}x${constraint.height.ideal}`);
       const stream = await navigator.mediaDevices.getUserMedia({ video: constraint });
       videoElement.srcObject = stream;
       videoElement.muted = true;
       await videoElement.play();
       await new Promise(resolve => videoElement.onloadedmetadata = resolve);
       bioCanvas.width = videoElement.videoWidth;
       bioCanvas.height = videoElement.videoHeight;
       console.log(`Camera initialized successfully with ${videoElement.videoWidth}x${videoElement.videoHeight}`);

       const processFrame = async () => {
         if (videoElement.readyState >= 2) {
           await hands.send({image: videoElement});
         }
         requestAnimationFrame(processFrame);
       };
       processFrame();
       return;
     } catch (error) {
       console.warn(`Failed to access camera with ${constraint.width.ideal}x${constraint.height.ideal}:`, error);
     }
   }
   throw new Error('Unable to access camera. Please check permissions and ensure a camera is available.');
  }

  async function startCamera() {
   console.log('startCamera() called');
   modeEl.innerText = "INITIALIZING CAMERA...";
   try {
     await initCamera();
   } catch (error) {
     console.error('Camera initialization failed:', error);
     console.error('Error name:', error.name);
     console.error('Error message:', error.message);
     if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
       modeEl.innerText = "ERROR: Camera permission denied";
       requestBtn.style.display = 'block';
     } else {
       modeEl.innerText = "ERROR: Camera access denied or unavailable";
       retryBtn.style.display = 'block';
     }
   }
  }

  requestBtn.addEventListener('click', async () => {
   requestBtn.style.display = 'none';
   modeEl.innerText = "REQUESTING PERMISSION...";
   try {
     await startCamera();
   } catch (error) {
     console.error('Permission request failed:', error);
     modeEl.innerText = "ERROR: Camera permission denied";
     requestBtn.style.display = 'block';
   }
  });

  retryBtn.addEventListener('click', async () => {
   retryBtn.style.display = 'none';
   modeEl.innerText = "INITIALIZING";
   try {
     await startCamera();
   } catch (error) {
     console.error('Retry failed:', error);
     modeEl.innerText = "ERROR: Camera access denied or unavailable";
     retryBtn.style.display = 'block';
   }
  });

  // Wait for scene.js to be fully loaded before starting camera
  setTimeout(() => {
   console.log('All scripts loaded, starting camera...');
   startCamera();
  }, 100);

  function animate() {
   requestAnimationFrame(animate);
   if (rainbowActive) {
    voxelManager.updateRainbowMode(true);
   } else {
    voxelManager.updateRainbowMode(false);
   }
   voxelManager.updatePhysics(gravityEnabled, getFloorY());
   renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>
